import sys

################################
# <方針>
# 1の街からスタートして、2の街へ到着する, 1の街からスタートして、3の街へ到着する, 1の街からスタートして、4の街へ到着する ..., 1の街からスタートして、Nの街へ到着する場合について考える。
# 上記の場合に対して、最短で何個の道路で移動できるのか記録する。
# Qiのクエリを与えたときに、cの街から1の街, 1の街からdの街へ、最短で何個の道路で移動できるのか演算する。
# 上記で求めた道路の個数が偶数なら、`Town`そうでないならば`Road`を出力する。
# <なぜcの街~dの街間の最短経路を演算することなく、cの街から1の街, 1の街からdの街へ、最短で何個の道路で移動できるのかの演算を行うのか？>
# 以下の記事を参照ください、すごく参考になります。🙇‍♂️
# https://yunix-kyopro.hatenablog.com/entry/2021/07/11/020240?_ga=2.121161536.9506465.1625937519-1301098457.1625937519
################################

# 再起の上限をつけるために利用する。
# 参考 : https://note.nkmk.me/python-sys-recursionlimit/
sys.setrecursionlimit(10**6)

def dfs(now):
    # 一度訪れた街は再度訪れない。
    if visited[now]:
        return

    # 訪れた街のフラグを変更する。
    visited[now] = True

    for to in edges[now]:
        # 1の街から、次の街へ移動するためにかかる距離を演算する。
        dep[to] = dep[now] + 1
        dfs(to)

# 標準入力を受け付ける。
N, Q = map(int, input().split())

# edges[0]は利用しない。
edges = [[] for _ in range(N + 1)]
for i in range(0, N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)

# 1の街からスタートして、2の街へ到着する, 1の街からスタートして、3の街へ到着する, 1の街からスタートして、4の街へ到着する ..., 1の街からスタートして、Nの街へ到着する場合について考える。
# 上記の場合に対して、最短で何個の道路で移動できるのか記録する。
# dep[0]は利用しない。
dep = [0] * (N + 1)

# 一度訪れた街へ移動しないためのフラグを用意する。
# visited[0]は利用しない。
visited = [False] * (N + 1)

# 1の街から移動を行う。
dfs(1)

for _ in range(Q):
    c, d = map(int, input().split())
    # Qiのクエリを与えたときに、cの街から1の街, 1の街からdの街へ、最短で何個の道路で移動できるのか演算する。
    # 上記で求めた道路の個数が偶数なら、`Town`そうでないならば`Road`を出力する。
    if (dep[c] + dep[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
